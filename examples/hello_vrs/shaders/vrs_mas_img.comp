#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WORKGROUP_SIZE 16

layout(local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE) in;

layout(push_constant) uniform PushUniforms
{
    mat4 vPMatrix;
	mat4 invPMatrix;
	mat4 invVMatrix;
	vec2 projAScale;
	vec2 imgSize;
} pushConst;
 
layout(set = 0, binding = 0, r8ui) uniform uimage2D targetImage;
layout(set = 0, binding = 1) uniform sampler2D prevFrameImage;
layout(set = 1, binding = 0, rgba8) uniform image2D debugImage;

vec3 project(vec4 pos)
{
	pos = pushConst.vPMatrix * pos;
	float s = sign(pos.z);
	pos = pos/pos.w;
	return vec3(pos.x, pos.y, pos.z * s);
}

vec3 NDCToWorld(vec3 posNDC)
{
	vec2 pos = posNDC.xy;
	vec4 positionVS = pushConst.invPMatrix * vec4(pos.xy * 2 - 1, posNDC.z, 1.0);
	vec3 position_vs = positionVS.xyz / positionVS.w;
	return vec3(pushConst.invVMatrix * vec4(position_vs, 1.0));
}

void main() {
	vec2 pixelSize = 1/pushConst.imgSize;
	ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
	vec2 xySSC = uv / pushConst.imgSize + 0.5 * pixelSize;

	//vec4 prevFrameVal = -clamp(texture(prevFrameImage, xySSC), -1, 0);
	vec4 prevFrameVal = texture(prevFrameImage, xySSC);
	vec4 prevFrameMotion = texture(prevFrameImage, xySSC);
	vec3 posWorld = NDCToWorld(vec3(xySSC, prevFrameVal.w));

	vec3 newPosNDC = (project(vec4(posWorld, 1)) + 1.0) / 2.0f;
	ivec2 newUV = ivec2(newPosNDC.xy * pushConst.imgSize);
	vec4 frameVal = texture(prevFrameImage, newPosNDC.xy);

	uvec4 prevShadingRate = imageLoad(targetImage, uv);

	float scaledVal = 1 - dot(-prevFrameVal.xy,-prevFrameVal.xy) * 10000;
	float shadingRate = scaledVal; // current texel diff
	shadingRate =  clamp(shadingRate, 0, 1) * 12.0;
	shadingRate = 0;

	newUV = ivec2((xySSC + 1 * prevFrameMotion.xy) * pushConst.imgSize + pixelSize);
	imageStore(targetImage, newUV, uvec4(clamp(shadingRate, 0, 11),0,0,0));

	// debug image
	imageStore(debugImage, uv, vec4(vec3(scaledVal * scaledVal + 0.5), 1.0));
}